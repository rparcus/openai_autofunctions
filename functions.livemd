# OpenAI Functions

```elixir
Mix.install([
  :req,
  :jason,
  :kin
])
```

## Test request

```elixir
model = "gpt-3.5-turbo-0613"
```

```elixir
req =
  Req.new(
    base_url: "https://api.openai.com",
    auth: {:bearer, System.get_env("LB_OPENAI_SECRET_KEY")}
  )
  |> Req.Request.append_request_steps(
    log: fn request ->
      IO.puts(["body: ", request.body || ""])

      request
    end
  )

:ok
```

```elixir
Req.get!(req, url: "/v1/models/:model", path_params: [model: model])
```

```elixir
Req.post!(req,
  url: "/v1/chat/completions",
  json: %{
    model: model,
    messages: [
      %{role: "system", content: "You are a helpful assistant. Be concise in all replies."},
      %{role: "user", content: "Hi! How are you?"}
    ]
  }
)
```

## Autofunctions

```elixir
defmodule Chat.Autofunctions do
  defmacro __using__(_) do
    quote do
      @after_verify Chat.Autofunctions
    end
  end

  @doc false
  def __after_verify__(module) do
    specs = module |> Code.Typespec.fetch_specs() |> normalize_specs()
    docs = module |> Code.fetch_docs() |> normalize_docs()

    functions =
      for {{name, arity}, params} <- specs_to_schemas(specs) do
        %{
          name: "#{arity}__#{name}",
          description: docs[{name, arity}],
          parameters: params
        }
      end

    :persistent_term.put({__MODULE__, module, :functions}, functions)
    :persistent_term.put({__MODULE__, module, :specs}, specs)

    :ok
  end

  @doc """
  Get the generated OpenAI function specs for the given model.
  """
  def get_functions(module) do
    :persistent_term.get({__MODULE__, module, :functions}, [])
  end

  @doc """
  Get the MFA for the requested function call.
  """
  def get_call(module, %{name: name, arguments: args}) do
    specs = :persistent_term.get({__MODULE__, module, :specs}, %{})

    # Turn the ARITY__NAME formatted function name into {:name, arity}
    [arity, name] = String.split(name, "__", parts: 2)
    {fun_name, _} = fun_arity = {String.to_existing_atom(name), String.to_integer(arity)}

    # Decode and order the args
    {params, _return} = specs[fun_arity]
    args = Jason.decode!(args, keys: :atoms!)
    args = for {name, _} <- params, do: Map.fetch!(args, name)

    {module, fun_name, args}
  end

  defp specs_to_schemas(specs) do
    for {fun_arity, _} = spec <- specs, into: %{} do
      {fun_arity, spec_to_schema_params(spec)}
    end
  end

  defp spec_to_schema_params({_fun_arity, {args, _return}}) do
    %{
      type: "object",
      properties: args_to_schema_properties(args),
      required: Keyword.keys(args)
    }
  end

  defp args_to_schema_properties(args) do
    for {name, type} <- args, into: %{} do
      {name, type_to_schema(type)}
    end
  end

  defp type_to_schema(:binary) do
    %{type: "string"}
  end

  defp type_to_schema(:pos_integer) do
    %{type: "integer", minimum: 1}
  end

  defp normalize_specs({:ok, specs}) do
    for {fun_arity, [{:type, _, :fun, [args, return]} | _]} <- specs,
        {:type, _, :product, args} = args,
        into: %{} do
      {fun_arity, {normalize_args(args), normalize_type(return)}}
    end
  end

  defp normalize_docs({:docs_v1, _, :elixir, _, _, _, docs}) do
    for {{:function, name, arity}, _, _, %{"en" => doc}, _} <- docs, into: %{} do
      {{name, arity}, String.trim(doc)}
    end
  end

  defp normalize_args(args) do
    Enum.with_index(args, fn
      {:ann_type, _, [{:var, _, name}, {:type, _, type, []}]}, _i ->
        {name, type}

      {:type, _, type, []}, i ->
        {:"arg_#{i}", type}
    end)
  end

  defp normalize_type({:type, _, atom, []}) when is_atom(atom) do
    atom
  end
end
```

```elixir
defmodule Chat.Message do
  alias Chat.Autofunctions

  defstruct [
    :role,
    :name,
    :content,
    :function_call,
    :mfa
  ]

  @type t :: %__MODULE__{
          role: :system | :assistant | :user | :function,
          name: String.t() | nil,
          content: String.t() | nil,
          function_call: map() | nil,
          mfa: {module(), atom(), [term()]} | nil
        }

  def assistant(%{function_call: %{} = fun_call}, mod) do
    %__MODULE__{
      role: :assistant,
      function_call: fun_call,
      mfa: Autofunctions.get_call(mod, fun_call)
    }
  end

  def assistant(%{content: content}, _mod) do
    %__MODULE__{role: :assistant, content: content}
  end

  def system(%{content: content}) do
    %__MODULE__{role: :system, content: content}
  end

  def user(%{content: content}) do
    %__MODULE__{role: :user, content: content}
  end

  def function(%{name: function_name, content: content}) do
    %__MODULE__{role: :function, name: function_name, content: content}
  end

  def to_json(%__MODULE__{role: role, content: content} = message) do
    %{role: role, content: content}
    |> put_non_nil(:name, message.name)
    |> put_non_nil(:function_call, message.function_call)
  end

  defp put_non_nil(map, _k, nil), do: map
  defp put_non_nil(map, k, v), do: Map.put(map, k, v)
end
```

```elixir
defmodule Chat do
  alias Chat.Autofunctions
  alias Chat.Message

  @system_message """
  You are a helpful assistant. Be concise in all replies.\
  """

  defstruct [
    :functions_module,
    model: "gpt-3.5-turbo-0613",
    messages: [
      Message.system(%{content: @system_message})
    ]
  ]

  def new(functions_module) do
    %__MODULE__{functions_module: functions_module}
  end

  def add(%Chat{} = chat, %Message{} = message) do
    %{chat | messages: [message | chat.messages]}
  end

  def run_function(%Chat{messages: [most_recent | _]} = chat) do
    case most_recent do
      %{role: :assistant, function_call: %{name: name}, mfa: {m, f, a}} ->
        result = apply(m, f, a)
        add(chat, Message.function(%{name: name, content: result}))

      _ ->
        chat
    end
  end

  def send!(%Chat{} = chat) do
    resp =
      Req.post!(req(),
        url: "/v1/chat/completions",
        decode_json: [keys: :atoms],
        json: %{
          model: chat.model,
          functions: Autofunctions.get_functions(chat.functions_module),
          # TODO: use Jason.Encoder, but can't in Livebook due to protocol
          # already being consolidated
          messages:
            chat.messages
            |> Enum.map(&Message.to_json/1)
            |> Enum.reverse()
        }
      )

    case resp do
      %{status: 200, body: %{choices: [%{message: message} | _]}} ->
        add(chat, Message.assistant(message, chat.functions_module))

      error ->
        IO.warn("Error: #{inspect(error)}")
        raise "bad resp"
    end
  end

  defp req do
    Req.new(
      base_url: "https://api.openai.com",
      auth: {:bearer, System.get_env("LB_OPENAI_SECRET_KEY")}
    )
  end
end
```

## Example 1

```elixir
alias Chat.Message
```

```elixir
defmodule ExampleModule do
  @moduledoc false

  use Chat.Autofunctions

  @doc """
  Duplicates a string.
  """
  @spec dup_string(string :: binary(), num_times :: pos_integer()) :: binary()
  def dup_string(string, n \\ 1) do
    String.duplicate(string, n)
  end
end
```

```elixir
chat = Chat.new(ExampleModule)
```

```elixir
chat =
  chat
  |> Chat.add(
    Message.user(%{
      content: """
      Please precisely duplicate the following string the number of times that it has characters:

      "foobar"
      """
    })
  )
  |> Chat.send!()
```

```elixir
chat = Chat.run_function(chat)
```

```elixir
chat.messages |> Enum.map(&Message.to_json/1)
```

```elixir
chat = Chat.send!(chat)
```

```elixir
Autofunctions.get_functions(ExampleModule)
```

```elixir
resp =
  Req.post!(req,
    url: "/v1/chat/completions",
    json: %{
      model: model,
      messages: [
        %{role: "system", content: "You are a helpful assistant. Be concise in all replies."},
        %{
          role: "user",
          content:
            ~S|Can you please carefully duplicate the following string as many times as there are letters in the string? "foobar"|
        }
      ],
      functions: Autofunctions.get_functions(ExampleModule)
    }
  )

%{"choices" => [%{"message" => %{"function_call" => fun_call}}]} = resp.body
```

```elixir
Autofunctions.get_response(ExampleModule, fun_call)
```

```elixir
resp =
  Req.post!(req,
    url: "/v1/chat/completions",
    json: %{
      model: model,
      messages: [
        %{role: "system", content: "You are a helpful assistant. Be concise in all replies."},
        %{
          role: "user",
          content:
            ~S|Can you please carefully duplicate the following string as many times as there are letters in the string? "foobar"|
        },
        %{
          content: "foobarfoobarfoobarfoobarfoobarfoobar",
          name: "2__dup_string",
          role: "function"
        }
      ],
      functions: Autofunctions.get_functions(ExampleModule)
    }
  )
```

<!-- livebook:{"offset":8819,"stamp":{"token":"QTEyOEdDTQ.FTfmk056PmnXrK8AQED-36_ZSMXO6g0mYADZ3oRojuDUVZ8dTxlLUvZvcS4.tbZA5vc_qFJUU45R.XrWBLgAcpJ04Hbt_6KcK1CBNPM1MPtPVsZwtourAjzEskkqU-avFW0L5rwMoRmf2xwa8EHQ.Wl509mugPFl1HKsh6eY8Fw","version":1}} -->
